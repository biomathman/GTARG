C$Procedure                         COMPGTC      SUBROUTINE COMPGT ( ORBIN  , DATIN  ,      &                    M      ,      &                    JEARTH, LTOP   , LSFLAG , DRAG,      &                    srpflag, cr, mass,     &			  dsmadt, tsmaswitch, sigma_dsma, DRAGBIASMODE,     &                    DAYS   , BOUNDS ,      &                    ORBITS , XINGS  ,      &			  WATCH,      &                    DV_FIXED, DV_PROP, DA_OD,      &			  SF_DVOD, SF_DRAG, SF_BOOST,      &                    NDRAG_BIAS, DRAG_BIAS, DV, TARGET_STRAT,      &			  BIAS_ODE, BIAS_DVE, BIAS_DRAGE, BIAS_BOOSTE,     &			  BIAS_ODW, BIAS_DVW, BIAS_DRAGW, BIAS_BOOSTW,     &                    ORBOUT , DATOUT ,      &                    LIMITS , LIMITS_WEST, LIMITS_EAST,      &                    NPTS   , TIMVEC , DGTVEC ,      &			  WESTVEC, EASTVEC, tmaneuver, tmaneuverc,      &			  betaprime, norbits, norbitsc, GTLONG, NREV,      &			  bootdata, sundata, IPAGE     &                  )CCC*******************************************************************************CC       Copyright (C) 1993, California Institute of Technology.  U.S.C       Government Sponsorhip under NASA Contract NAS7-918 isC       acknowledged.CC*******************************************************************************CC$ LogCC  Date         Name               DescriptionC  -----------------------------------------------------------------------------C  24-JUL-1990  Eric Cannell       creation of COMPGTC  29-AUG-1991  Bruce Shapiro      include targeting biasesC   2-DEC-1992			   Tabular output of ground track & elements.C  23-FEB-1993                     Correct usage of hi/low drag errors in gt.C				   old way: take maximum of two groundC					track diff, apply equally toC					east and westC				   new way: apply hi drag error to eastC					lo drag error westCC$ PurposeCC  COMPGT computes a ground track by determining the distance from a reference C  ground track at ascending nodes. For computational expediency, the inputC  M allows COMPGT to examine every m-th ascending node (i.e., every 4th one).CC  The computed ground track is either a particular number of days longC  (DAYS>0) or terminates when it leaves the valid band.CC$ Input_ArgumentsCC  Name    Type   Dim        Units   DescriptionC  -----------------------------------------------------------------------------C  ORBIN     DP     6       km,deg   input orbit of (a,e,i,LAN,w,M)C  DATIN   C*25     1          -->   input epoch of ORBIT in TIMETRANS formatC                                    'dd-mmm-yyyy hh:mm:ss.fffC  M          I     1            -   forces COMPGT to examine every M-thC                                    ascending node. For example, one hopes C                                    that M=4 is a lot faster computationallyC                                    and almost as accurate as M=1.C  LTOP       I     1            -   the maximum L index to consider in LSRGP'sC                                    Earth gravity model (i.e., LTOP=17 meansC                                    model up to J17).C  LSFLAG     L     1            -   if true, luni-solar effects are ON in theC                                    LSRGP libraryC  DRAG       L     1            -   if true, atmospheric drag effects are ONC                                    in the PROP subroutine. Note that onlyC                                    drag can affect semi-major axis.C  dsmadt      R*8  2	m/day	     extra (d/dt) on SMAC  tsmaswitch  R*8  A       secon6s  time to switch between dsmadt valuesC  sigma_dsma  r*8  2                sigmas in dsmadtC  DRAGBIASMODE C*4 1		-    'FLUX' or 'GT' - use flux biases orC					use table of GT biases to computeC					the component of ground track errorC					which is due to sf/geomag data errorsC  DAYS       I     1         days   if DAYS>0, the ground track is run outC                                    DAYS days, regardless of whether or notC                                    the ground lies within or without the C                                    valid band defined by BOUNDS.C                                    if DAYS=<0, the ground track is run outC                                    until it leaves the valid band as definedC                                    by input BOUNDS. However, if a ground C                                    track lies completely outside of the validC                                    band, COMPGT will terminate the track afterC                                    TOLONG days.C  BOUNDS    DP     2           km   the low and high boundaries (in that order)C                                    of the valid ground track band as measuredC                                    from the reference ground track. Usually,C                                    BOUNDS will be something like -/+ 1 km.C                                    But, BOUNDS could be (.5,1.5), i.e., fullyC                                    right of the reference ground track.C                                    BOUNDS is used only when DAYS=<0.C  ORBITS     I     1            -   number of equator crossings XINGSC  XINGS     DP ORBITS         deg   reference equator crossings from REF_EQXINGC  JEARTH    DP (2:29)           -   earth field zonal coefficients J2, J3, ...C  WATCH      L     1            -   watch the nodes as they are being calculatedC  DV_FIXED,  DP    1       mm/sec   Fixed errorC  DV_PROP,   DP    1            -   Proportional error, proportion of dvC  DA_OD,     DP    1            m   od error in aC  SF_DVOD,   DP    1            -   scale factor for gt bias (DV & OD biases)C  SF_DRAG,   DP    1            -   scale factor for gt bias (drag biases)C  SF_BOOST   DP    1            -   scale factor for gt bias (boost )C  NDRAG_BIAS, I    1            -   number of drag bias pointsC  DRAG_BIAS, DP  NDRAG_BIAS    km   bias in gt due to dragC  DV         DP    1       mm/sec   the actual delta-v (used for proportionalC					errorC  TARGET_STRAT c*8 1                'UNBIASED', 'WESTGT', 'EASTGT'C  BIAS_OD    r   MXNODES            biases for odC  BIAS_DV				    for dvC  BIAS_FLUX				    for fluxC  IPAGE     I                        PAGE NUMBERCC$ Output_ArgumentsCC  Name    Type   Dim        Units   DescriptionC  -----------------------------------------------------------------------------C  ORBOUT    DP     6       km,deg   final orbit of (a,e,i,LAN,w,M)C  DATOUT  C*25     1          -->   final epoch of ORBOUT in TIMETRANS formatC                                    'dd-mmm-yyyy hh:mm:ss.fffC  LIMITS    DP   4,2      days,km   with regard to ascending nodes, theC                                    time (in days) and ground track offsetC                                    (in km) of the first node, the furthestC                                    west node, the furthest east node, andC                                    the last node of the ground track. LIMITSC                                    allows GTARG to classify the ground track.C                                                         time   offsetC                                                       |------|--------|C                                    first node         | days |   km   |C                                    furthest west node | days |   km   |C                                    furthest east node | days |   km   |C                                    final node         | days |   km   |C                                                       |------|--------|C  LIMITS_WEST DP   4,2      days,km same as LIMITS, but applies to 95 pctleC  LIMITS_EAST DP   4,2		     (or whatever maximum bias is used) C				     westernmost ground track.C  NPTS       I     1            -   number of data points TIMVEC and DGTVECC  TIMVEC    RL MXNODE        days   time in days of each nodes examined, usedC                                    in plottingC  DGTVEC    RL MXNODE          km   ground offset from reference track ofC                                    each node examined, used for plottingC  WESTVEC   RL MXNODE		KM   same as dgtvec, for WEST 95 pctlC  EASTVEC   RL MXNODE		km   same as dgtvec, for EAST 95 pctlC  TMANEUVER DP     3         days   time to subsequent maneuver (worksC					correctly for LONG targeting)C					1 = west, 2 = unbiased, 3 = eastC  BETAPrime DP     1          deg   Beta Prime angle at DATINC  norbits   i      3            -   # of orbits until next maneuverC					(1)=west; (2)=unbiasd; (3)=eastCC$ RestrictionsCC  1] Note that if DAYS=<0 and a ground track lies completely outside of theC     valid band, then COMPGT will only run out that ground track for TOLONGC     days.CC$ Library_LinksCC  Entry Point Name              LocationC  -----------------------------------------------------------------------------C  CH2JD                         TIMETRANSC  DCLOSE                        TPXUTILC  DVMOVE                        TPXUTILC  MNODES                        GTARGC  SIDANG                        TPXORBCC$ Global/Common StuffC      double precision RE                       ! in kilomters      double precision earth_freq               ! radians / second      double precision WEARTH                   ! meters / day      double precision mu_earth                 ! km**3/sec      double precision mu_moon                  ! km**3/sec      double precision mu_sun                   ! km**3/sec      double precision sid_day                  ! seconds      double precision DEG2KM                   ! kilometers/deg      double precision flat      common / physical_constants /     &    RE,         earth_freq,     WEARTH,     mu_earth,     &    mu_moon,    mu_sun,         sid_day,    DEG2KM, flat      common / tt / terminal      character*12 terminalC$ ParametersC      logical		   trace      parameter		(  trace = .false. )      logical 		   trace_Site, trace_overflights      parameter		(  trace_site = .FALSE. )      parameter         (  trace_overflights = .false. )      INTEGER              MXNODE      PARAMETER          ( MXNODE = 20000 )      DOUBLE PRECISION     TOLONG      PARAMETER          ( TOLONG = 15D0 )      character*4	hi      parameter	 	(hi = 'HI')      character*4	lo      parameter		(lo = 'LO')      DOUBLE PRECISION     PI          PARAMETER          ( PI     = 3. 14159 26535 89793 23846 D0 )      DOUBLE PRECISION     TWOPI      PARAMETER          ( TWOPI = 2*PI )C      DOUBLE PRECISION     REC      PARAMETER          ( RE     = 6378.14D0 )C      DOUBLE PRECISION     DEG2KMC      PARAMETER          ( DEG2KM = PI * RE / 180D0 )C      DOUBLE PRECISION     WEARTHC      PARAMETER          ( WEARTH = 2*PI*RE*86400000.0/86164.0)C      DOUBLE PRECISION      MUC      PARAMETER          ( MU = 3.9860044807345D14 )CC$ Declarations_of_Input_and_Output_ArgumentsC      logical 		   anomalous_force      DOUBLE PRECISION	   BETAP, betaprime, alpha, sunalpha      DOUBLE PRECISION     BOUNDS ( 2 )      CHARACTER*25         DATIN      CHARACTER*25         DATOUT      INTEGER              DAYS      DOUBLE PRECISION     DGTVEC ( MXNODE )      character*4	   dragbiasmode      double precision     dsmadt(2), tsmaswitch, sigma_dsma(2)      DOUBLE PRECISION     EASTVEC ( MXNODE )      DOUBLE PRECISION     WESTVEC ( MXNODE )      REAL                 BIAS_ODE ( MXNODE ), BIAS_BOOSTE(MXNODE)      REAL 		   BIAS_DVE ( MXNODE )      REAL		   BIAS_DRAGE ( MXNODE )      REAL                 BIAS_ODW ( MXNODE ), BIAS_BOOSTW(MXNODE)      REAL 		   BIAS_DVW ( MXNODE )      REAL		   BIAS_DRAGW ( MXNODE )      LOGICAL              DRAG      INTEGER 		   IPAGE      double precision     jearth ( 2:29 )      double precision     gtlong (MXNODE)       DOUBLE PRECISION     LIMITS ( 4 , 2 )      DOUBLE PRECISION     LIMITS_WEST ( 4, 2 )      DOUBLE PRECISION     LIMITS_EAST ( 4, 2 )      LOGICAL              LSFLAG, srpflag      double precision     mass, cr      INTEGER              LTOP      INTEGER              M      integer		   norbits ( 3 ), norbitsc ( 3 )      INTEGER              NPTS      DOUBLE PRECISION     ORBIN  ( 6 )      INTEGER              ORBITS      DOUBLE PRECISION     ORBOUT ( 6 )      integer              nrev ( MXNODE )      DOUBLE PRECISION     TIMVEC ( MXNODE )      DOUBLE PRECISION     TMANEUVER ( 3 ), TMANEUVERC ( 3 )      DOUBLE PRECISION     XINGS  ( ORBITS )      LOGICAL              watch      DOUBLE PRECISION     DV_FIXED      DOUBLE PRECISION     DV_PROP      DOUBLE PRECISION     DA_OD      DOUBLE PRECISION     SF_DVOD, SF_DRAG, SF_BOOST      INTEGER              NDRAG_BIAS      DOUBLE PRECISION     DRAG_BIAS ( NDRAG_BIAS )      DOUBLE PRECISION     DV      character*8          target_strat      logical fluxbias          double precision     bootdata(mxnode, 6)      double precision     sundata(mxnode, 2)CC	integer MXFLUX	parameter (MXFLUX=4000)      common  /boost/      anomalous_force,      &			ndsmadt_data, dsmadt_data, dsmadt_epoch,     &                     dsmadt_data_sigma, plot_boost,      &			   DSMADT_DATES, XDSMADT_DATES, DSMADT_SIGMAS      double precision     dsmadt_data(MXFLUX)      double precision     dsmadt_data_sigma, dsmadt_epochjd      DOUBLE PRECISION     DSMADT_SIGMAS(MXFLUX), XDSMADT_DATES(MXFLUX)      character*25         dsmadt_epoch, DSMADT_DATES(MXFLUX)      integer              ndsmadt_data      logical              plot_boost      common /error_flags/ quad_err_boost, quad_err_drag      logical quad_err_boost, quad_err_drag      double precision     da_boost      double precision     xt1, xt2, y1, y2      INTEGER FINDDATE      EXTERNAL FINDDATE      integer mx_sites, mx_overflights      parameter (mx_sites = 10)      parameter (mx_overflights = 100)      common  /site_data/ NSITES, SITE_LOC, SITE_NODE, SITE_GCLAT,     &          SITE_NAME, site_STRAT, overflights, noverflights      integer nsites, site_node(mx_sites), noverflights(MX_SITES)      double precision site_loc(2,mx_sites), site_gclat(Mx_sites)      double precision overflights(mx_sites, mx_overflights, 5)CC	overflights(site #, j, 1) = timeC                              2) = offset, kmC                              3) = geodetic latitudeC			       4) = longitudeC			       5) = node numberC      character*10 site_name(mx_sites), site_STRAT*6CC$ Declarations_of_Local_VariablesC           double precision     cycle_length      CHARACTER*25         DATLST, datlsthi, datlstlo      CHARACTER*25         DATNOW, datnowhi, datnowlo      DOUBLE PRECISION     DGT, DGTWest, DGTEast, DGTHI, DGTLO      double precision     dgthi_used, dgtlo_used      double precision     DGTHI_LAST, DGTLO_LAST      DOUBLE PRECISION     DIFF, DIFFHI, DIFFLO      DOUBLE PRECISION     ECL, ECLHI, ECLLO      LOGICAL              ERROR, FIRSTTIME      INTEGER              IDX, itdays, itdayslast      DOUBLE PRECISION     JDLST, JDLSTHI, JDLSTLO      DOUBLE PRECISION     JDNOW, JDNOWHI, JDNOWLO      DOUBLE PRECISION      MU      DOUBLE PRECISION     ORBLST ( 6 ), ORBLSTHI (6), orblstlo(6)      DOUBLE PRECISION     ORBNOW ( 6 ),  ORBNOWHI(6), orbnowLO(6)      DOUBLE PRECISION     ORBINHI( 6 ), ORBINLO (6)      DOUBLE PRECISION     CARSITE(6), orbsite(6)      INTEGER              REFIDX, REFIDXHI, REFIDXLO      DOUBLE PRECISION     TDAYS, TDAYSHI, TDAYSLO      DOUBLE PRECISION     TDAYSHI_LAST,TDAYSLO_LAST      DOUBLE PRECISION     TSTOP      LOGICAL              WASIN      LOGICAL              WASIN_EAST      LOGICAL              WASIN_WEST      LOGICAL              WASIN_UNBIASED      DOUBLE PRECISION     VEL      DOUBLE PRECISION     partial_dgtdv, partial_dgtda_boost      DOUBLE PRECISION     partial_dgtda      DOUBLE PRECISION     DV_ERROR      DOUBLE PRECISION     GT_ERROR, PERIOD, GT_ERROR_EAST      DOUBLE PRECISION     GT_ERROR_WEST, PERIOD_DAYS      DOUBLE PRECISION     GTE_DV, GTE_OD, GTE_DRAG, GTE_BOOST      DOUBLE PRECISION     GTE_BOOST_ENV      DOUBLE PRECISION     GTE_BOOST_OLD      LOGICAL              GTE_BOOST_ARRAY      DOUBLE PRECISION     alpha_BOOST, alpha_BOOST_OLD      double precision     delta_boost, delta_boost_old      DOUBLE PRECISION     GAMMA_BOOST, GAMMA_BOOST_OLD      double precision     beta_boost, beta_star      DOUBLE PRECISION     GTE_DRAG_HI, GTE_DRAG_LO      DOUBLE PRECISION     old_GTE_DRAG_HI, old_GTE_DRAG_LO      DOUBLE PRECISION     delta_GTE_DRAG_HI, delta_GTE_DRAG_LO      DOUBLE PRECISION     optimistic_GTE_DRAG_HI      DOUBLE PRECISION     optimistic_GTE_DRAG_LO      DOUBLE PRECISION     GTE_DVOD, GTE_DRAG_EAST, GET_DRAG_WEST           double precision     secnow, xtsite, xtsite1, xtsite2      character*25	   tsite, tsite1, tsite2      double Precision     sinDtheta, cosdtheta, dtheta, cosB      double precision     sinl,sini,GTES_A, GTES_B, GTES_D, GTES      double Precision     cosl, sitelong, sitelat,NuNode,NuSite      double Precision     EASite, MASite, SinEASite, CosEASite      double Precision     cosNuSite, SinNuSite,TOF, MEANMOTION      double Precision     EarthShift, NODESHIFT, DeltaNJ2, GTES_DD      double Precision     SatLongitude, SatGDLat, SatGCLat      double precision     ErrGDLat, SatLongitude1, SatLongitude2      double Precision     SatGDLat1, SatGDLat2, SatGCLat1, SatGCLat2      double Precision     TOF1, TOF2, ErrLimit      logical              ODD,ONEOK, CLOSE, NEWCC$ External_StatementsC      DOUBLE PRECISION     CH2JD, ch2sec      character *25	   sec2ch      EXTERNAL             CH2JD, ch2sec, sec2ch      INTEGER              DCLOSE                EXTERNAL             DCLOSE      DOUBLE PRECISION     RNG360      EXTERNAL             RNG360      DOUBLE PRECISION     SIDANG      EXTERNAL             SIDANG      character*8	   goto_string      external		   goto_string      data firsttime /.true./CC$ MethodC-&C       write(8,*) 'COMPGT:ORBIN=',orbin       fluxbias = ( (dragbiasmode .eq. 'FLUX' ) .or.     &		    (dragbiasmode .eq. 'flux' ) )C      convert mu from km**3/sec to m**3/second       mu = 1.0e9 * mu_earthC	write(8,*) 'COMPGT:MU=',MUC       do k = 1, 3          tmaneuver  (k) = 0.0          tmaneuverc (k) = 0.0	  norbits(k) = 0	  norbitsc(k) = 0       end doCC       write(8,*) 'COMPGT:ORBIN=',orbinC	write(8,*) 'COMPGT:MU=',MU        vel = sqrt ( MU / (1000.0 * orbin(1)) ) * 1000.0CC	period in secondsC       period = SQRT ( orbin(1)**3 / MU_EARTH ) * 2 * PI       PERIOD_DAYS = PERIOD/86400.0D0	cycle_length = period_days*dble(real(orbits))       CC	time independent part of partials (these are not the C	complete partials, only the coefficients that are timeC	independent)C       partial_dGTdv = -3 * WEARTH / vel       partial_dGTda = 1.5 * WEARTH / (1000.0 * orbin(1))       partial_dGTda_boost = 0.5 * partial_dGTdaCC	sigma in boost in sma in meters/orbitC       da_boost = dsmadt_data_sigma * period / 86400.0d0C	        write(8,*) 'da_boost=',da_boostC                write(8,*) 'partial_dgtda_boost=',partial_dgtda_boost      GTE_DRAG_HI = 0.0      GTE_DRAG_LO = 0.0      OPTIMISTIC_GTE_DRAG_HI = 0.0      OPTIMISTIC_GTE_DRAG_LO = 0.0CC	INITIALIZE BOOST ERROR MODELC      GTE_BOOST_ARRAY = ( DSMADT_DATA_SIGMA.LT.0D0 )      ALPHA_BOOST = 0.0      BETA_STAR = PERIOD_DAYS**2 * (4.0/3.0) *      &	( DBLE(REAL(M*M)) - 0.375 * DBLE(REAL(M)) + 0.125 )      DELTA_BOOST = 0.0      GAMMA_BOOST = 0.0      ALPHA_BOOST_OLD = 0.0      DELTA_BOOST_OLD  = 0.0      GAMMA_BOOST_OLD  = 0.0      GTE_BOOST = 0.0      MMPRIME = M * (M-1)      MPRIME = M * (M+2)CC	compute total delta-v errorC	if ( dabs(dv) .gt. 1.0D-6) then          dv_error = sqrt ( dv_fixed**2 + (dv_prop * dv)**2 )        else          dv_error = 0.0d0        end ifCC	print a header to the screen C        if ( watch .and. TERMINAL.eq.'VT100' ) then             write (6,102) goto_string (14,55),'Days'             write (6,1101) goto_string (15,1),'West'             write (6,1101) goto_string (16,1),'  GT'             write (6,1101) goto_string (17,1),'East'             write (6,102) goto_string (15,25),'a'             write (6,102) goto_string (16,25),'e'             write (6,102) goto_string (17,25),'i'             write (6,102) goto_string (15,55),'RAAN'             write (6,102) goto_string (16,55),'AOP'             write (6,102) goto_string (17,55),'M'1101        format(' ',A8,A4) 102        format(' ',A8,A4)         end ifC1    Set data arrays to zero for TGTGT.      DO 101 IDX = 1 , MXNODE         TIMVEC( IDX ) = 0.0D0         DGTVEC( IDX ) = 0.0D0	 EASTVEC ( IDX ) = 0.0D0         WESTVEC ( IDX ) = 0.0D0101   CONTINUEC1    Determine the time to stop. Either TSTOP is DAYS when DAYS > 0 orC1    TOLONG in case ground is completely outside of valid band. Basically,C1    a ground track outside of the valid band is not of much use, so thereC1    is no point in running it out for a long period of time.      IF ( DAYS .GT. 0 ) THEN         TSTOP = DAYS      ELSE         TSTOP = TOLONG      END IFC1    Take the first step to the first M-th ascending node.      if (fluxbias ) then        call dvmove ( 6, orbin, orbinhi )        call dvmove ( 6, orbin, orbinlo )      end ifC	write(6,*) 'COMPGT> Calling MNODES'      CALL MNODES( ORBIN  , DATIN  , M      , JEARTH, LTOP   ,      &		   LSFLAG , DRAG   ,      &              srpflag, cr, mass, dsmadt, tsmaswitch,      &		   sigma_dsma,     &		  'TRUE', ORBNOW , DATNOW ,     &		   sunalpha, betaprime )C	write(6,*) 'COMPGT> Returning From MNODES'      do i=1,6	bootdata(1, i) = orbnow(i)      end do      sundata(1,1) = sunalpha      sundata(1,2) = betaprimeC     write(8,*) 'COMPGT:betaprime=',betaprime      if ( fluxbias ) then          CALL MNODES( ORBINHI, DATIN  , M  , JEARTH, LTOP   ,      &		   LSFLAG , DRAG,      &              srpflag, cr, mass, dsmadt, tsmaswitch, sigma_dsma,     &		   HI, ORBNOWHI , DATNOWHI, alpha, betap )          CALL MNODES( ORBINLO, DATIN  , M  , JEARTH, LTOP   ,      &		   LSFLAG, DRAG,      &              srpflag, cr, mass, dsmadt, tsmaswitch, sigma_dsma,     &		   LO, ORBNOWLO , DATNOWLO, alpha, betap )      end ifC      if ( trace ) thenC         write (50,*) 'COMPGT *** True:', orbin, datin, orbnow, datnowC         write (50,*) 'COMPGT *** Hi  :', orbinhi, datin, orbnowhi, C     *	    datnowhiC         write (50,*) 'COMPGT *** Lo  :', orbinlo, datin, orbnowlo, C     *	    datnowloC      end ifC1    Compute the equator crossing longitude of this node. Since LANC1    equals right ascension at this point, longitude is LAN - siderealC1    angle of Greenwich.      ECL = RNG360( ORBNOW(4) - SIDANG( DATNOW , 0D0 ) )      if (fluxbias) then	 ECLHI = RNG360( ORBNOWHI(4) - SIDANG( DATNOWHI , 0D0 ) )         ECLLO = RNG360( ORBNOWLO(4) - SIDANG( DATNOWLO , 0D0 ) )      end ifC1    Determine the index of the reference equator crossing longitudeC1    that closest matches the crossing longitude of this first node.      REFIDX = DCLOSE( ECL , ORBITS , XINGS )      if (fluxbias) then         REFIDXHI = DCLOSE( ECLHI , ORBITS , XINGS )         REFIDXLO = DCLOSE( ECLLO , ORBITS , XINGS )      end ifC1    Compute the difference between the actual and reference equatorial C1    crossing longitude and then update the reference index.      DIFF    = ECL  - XINGS( REFIDX )       GTLONG(1) = ECL      NREV(1) = REFIDX      if (fluxbias ) then         DIFFHI    = ECLHI  - XINGS( REFIDXHI )          DIFFLO    = ECLLO  - XINGS( REFIDXLO )       end if      IF      ( DIFF .GT. 180D0 ) THEN         DIFF = DIFF - 360D0      ELSE IF ( DIFF .LT.-180D0 ) THEN         DIFF = DIFF + 360D0      END IF      if (fluxbias) then         IF      ( DIFFHI .GT. 180D0 ) THEN            DIFFHI = DIFFHI - 360D0         ELSE IF ( DIFFHI .LT.-180D0 ) THEN            DIFFHI = DIFFHI + 360D0         END IF         IF      ( DIFFLO .GT. 180D0 ) THEN            DIFFLO = DIFFLO - 360D0         ELSE IF ( DIFFLO .LT.-180D0 ) THEN           DIFFLO = DIFFLO + 360D0         END IF      end ifC      if (trace) thenC         write (50,*) 'COMPGT ECL,HI,LO',ECL,ECLHI,ECLLOC         write (50,*) 'COMPGT IDX,HI,LO',REFIDX,REFIDXHI,REFIDXLOC         write (50,*) 'COMPGT DIF,HI,LO',DIFF,DIFFHI,DIFFLOC      end if      REFIDX = REFIDX + M      IF ( REFIDX .GT. ORBITS ) REFIDX = REFIDX - ORBITS      if (fluxbias) then         REFIDXHI = REFIDXHI + M         IF ( REFIDXHI .GT. ORBITS ) REFIDXHI = REFIDXHI - ORBITS         REFIDXLO = REFIDXLO + M         IF ( REFIDXLO .GT. ORBITS ) REFIDXLO = REFIDXLO - ORBITS      end ifC1    Convert the difference to kilometers.      DGT    = DIFF * DEG2KM       if (fluxbias) then         DGTHI  = DIFFHI * DEG2KM         DGTLO  = DIFFLO * DEG2KM      end ifC      if (trace) thenC         write(50,*) 'COMPGT DGT,HI,LO:',DGT,DGTHI,DGTLOC      end ifC1    Compute the time in days of this ascending node.      JDLST = CH2JD( DATIN  , .TRUE. , ERROR )      JDNOW = CH2JD( DATNOW , .TRUE. , ERROR )      TDAYS = JDNOW - JDLST      if (fluxbias) then         JDLSTHI = JDLST         JDLSTLO = JDLST         JDNOWHI = CH2JD( DATNOWHI , .TRUE. , ERROR )         JDNOWLO = CH2JD( DATNOWLO , .TRUE. , ERROR )         TDAYSHI = JDNOWHI - JDLSTHI         TDAYSLO = JDNOWLO - JDLSTLO         itdays = int(tdays)      end ifC1    Store the time and offset of this first node. Also, this only nodeC1    is the furthest west and east.      LIMITS(1,1) = TDAYS      LIMITS(1,2) = DGT      LIMITS(2,1) = TDAYS      LIMITS(2,2) = DGT      LIMITS(3,1) = TDAYS      LIMITS(3,2) = DGT      TIMVEC(1)   = TDAYS       DGTVEC(1)   = DGT       GTE_DV = 0.001 * SF_DVOD * partial_dGTdV * DV_ERROR * TDAYS      GTE_OD = 0.001 * SF_DVOD * partial_dGTda * DA_OD * TDAYS       IF (anomalous_force .and. GTE_BOOST_ARRAY) THENCC	INSERT CODE HERE TO OBTAIN DA_BOOST FROM THE APPROPRIATEC	DATA ARRAY, DSMADT_SIGMAS(I)C	DA_BOOST = DATA FROM ARRAY * PERIOD * M / 86400.0CC	NEED ALSO TO INCORPORATE SCALE FACTOR INTO EQUATIONS         IF (DSMADT_EPOCH .EQ. ' ') then           IDATE = finddate ( DATNOW, .FALSE., DSMADT_dates,      &		XDSMADT_DATES, nDSMADT_DATA )           IF (IDATE .LT. 1 .OR. IDATE .GE. NDSMADT_DATA) THEN              WRITE(8,*) 'Time ', datnow,' is out of range of ',     &			' Boost Sigma Array.'              DA_BOOST = 0.0D0           ELSE              XT1 = XDSMADT_DATES(IDATE)              XT2 = XDSMADT_DATES(IDATE+1)              Y1 = dsmadt_sigmas(IDATE)              Y2 = dsmadt_sigmas(IDATE+1)              da_boost = y1 +      &           (CH2SEC(DATNOW,.TRUE., ERROR) - XT1)      &		 * ( (y2-y1)/(XT1-XT2) )              da_boost = da_boost * PERIOD_DAYS            END IF        ELSE	   dsmadt_epochjd = ch2jd ( dsmadt_epoch, .true., ERROR)           IDATE = jdnow - dsmadt_epochjd           IF (IDATE .LT. 1 .OR. IDATE .GE. NDSMADT_DATA) THEN              WRITE(8,*) 'Time ', datnow,' is out of range of ',     &			' Boost Sigma Array.'              DA_BOOST = 0.0D0           ELSE              da_boost = DSMADT_SIGMAS(IDATE)              da_boost = da_boost * M * PERIOD_DAYS            END IF        END IF           GTE_BOOST_OLD = GTE_BOOST        IF (QUAD_ERR_BOOST) THEN 	   ALPHA_BOOST_OLD = ALPHA_BOOST	   GAMMA_BOOST_OLD = GAMMA_BOOST           ALPHA_BOOST = ALPHA_BOOST_OLD +      &			m * (PERIOD_DAYS**2) * (DA_BOOST**2)	   GAMMA_BOOST = 2.0*m*ALPHA_BOOST_OLD + GAMMA_BOOST_OLD     &		+ MMPRIME * (PERIOD_DAYS**2) * (DA_BOOST**2)	   BETA_BOOST = BETA_STAR * (DA_BOOST**2)           GTE_BOOST = SQRT( GTE_BOOST_OLD**2      &		+ ( PARTIAL_DGTDA**2 )      &		   * ( MPRIME * ALPHA_BOOST_OLD +      &		       M * GAMMA_BOOST_OLD + BETA_BOOST ) )C	    write(8,*) 'm=',mC	    write(8,*) 'ALPHA_BOOST_OLD=',ALPHA_BOOST_OLDC           write(8,*) 'PERIOD_DAY     =',PERIOD_DAYSC           write(8,*) 'PERIOD_DAYS**2 =',PERIOD_DAYS**2C           write(8,*) 'DA_BOOST       =',DA_BOOSTC           write(8,*) 'DA_BOOST**2    = ',DA_BOOST**2C           write(8,*) 'M*T^2*DA^2     =',C     &		m * (PERIOD_DAYS**2) * (DA_BOOST**2)C           write(8,*) 'ALPHA_BOOST    =',ALPHA_BOOST        ELSE           DELTA_BOOST_OLD = DELTA_BOOST	   DELTA_BOOST = DELTA_BOOST_OLD +      &			M * M * PERIOD_DAYS *      &			PARTIAL_DGTDA * DA_BOOST	   GTE_BOOST = GTE_BOOST_OLD + DELTA_BOOST_OLD +     &			PARTIAL_DGTDA * PERIOD_DAYS * DA_BOOST *     &			0.5 * mmprime        END IF      ELSE if (anomalous_force) then          if (quad_err_boost) then            GTE_BOOST = partial_dgtda_boost *      &		da_boost *      &		sqrt (2.0d0/3.0d0) *     &		sqrt (  ( tdays * 86400.0 / period) *     &			( tdays - PERIOD/86400.0) *      &	                ( 2*tdays - PERIOD/86400.0)   )         else            GTE_BOOST = partial_dgtda_boost *      &		da_boost *     &		tdays * (1 + tdays * 86400.0 / PERIOD )         end if      else	  gte_boost = 0.0d0      END IF      GTE_BOOST_ENV = 0.001 * SF_BOOST * GTE_BOOST      GTE_DVOD = sqrt ( GTE_DV**2 + GTE_OD**2 )      if (fluxbias) then         gte_drag = 0	 if (itdays.gt.0)      &       drag_bias(ITDAYS) = gte_drag         itdayslast = itdaysC	 if (itdays .eq. 0 ) write(8,*) 'ITDAYS = 0!!!'      else         call interp_drag_bias (tdays, drag_bias, ndrag_bias, gte_drag )      end if      GT_ERROR = sqrt ( GTE_DVOD**2 + GTE_DRAG**2 + GTE_BOOST_ENV**2)      DGTWest = DGT - GT_ERROR      DGTEast = DGT + GT_ERROR      EASTVEC( 1 )    = DGTEast      WESTVEC( 1 )    = DGTWest       BIAS_ODE( 1 )   = SNGL ( DGT+abs(GTE_OD) )      BIAS_DVE( 1 )   = SNGL ( DGT+abs(GTE_DV) )      BIAS_DRAGE( 1 ) = SNGL ( DGT+abs(GTE_DRAG) )      BIAS_BOOSTE(1)  = SNGL ( DGT+ABS(GTE_BOOST_ENV))      BIAS_ODW( 1 )   = SNGL ( DGT-abs(GTE_OD) )      BIAS_DVW( 1 )   = SNGL ( DGT-abs(GTE_DV) )      BIAS_DRAGW( 1 ) = SNGL ( DGT-abs(GTE_DRAG) )      BIAS_BOOSTW(1)  = SNGL ( DGT- ABS(GTE_BOOST_ENV))      LIMITS_WEST(1,1) = TDAYS      LIMITS_WEST(1,2) = DGT      LIMITS_WEST(2,1) = TDAYS      LIMITS_WEST(2,2) = DGT      LIMITS_WEST(3,1) = TDAYS      LIMITS_WEST(3,2) = DGT      LIMITS_EAST(1,1) = TDAYS      LIMITS_EAST(1,2) = DGT      LIMITS_EAST(2,1) = TDAYS      LIMITS_EAST(2,2) = DGT      LIMITS_EAST(3,1) = TDAYS      LIMITS_EAST(3,2) = DGTC1    Determine if this first node was in or out of the valid band.      IF ( BOUNDS(1) .LT. DGT .AND. DGT .LT. BOUNDS(2) ) THEN         WASIN = .TRUE.          WASIN_EAST = .TRUE.          WASIN_WEST = .TRUE.          WASIN_UNBIASED = .TRUE.       ELSE           WASIN = .FALSE.         WASIN_EAST = .FALSE.         WASIN_WEST = .FALSE.         WASIN_UNBIASED = .FALSE.      END IFC1    Continue stepping from M-th ascending node to M-th ascending nodeC1    until  stopping criteria is reached.      NPTS  = 1C1    Do...901   CONTINUEC2       Check that data arrays are not filled.         NPTS = NPTS + 1         IF ( NPTS .GT. MXNODE ) THEN            WRITE(*,301)            WRITE(8,301)301         FORMAT(/,1X,'GTARG: COMPGT has filled its data arrays.')            STOP         END IFC2       Save the last orbit and dates.         CALL DVMOVE( 6 , ORBNOW , ORBLST )         DATLST = DATNOW         JDLST  = JDNOW         if (fluxbias) then            CALL DVMOVE( 6 , ORBNOWHI , ORBLSTHI )            DATLSTHI = DATNOWHI            JDLSTHI  = JDNOWHI            CALL DVMOVE( 6 , ORBNOWLO , ORBLSTLO )            DATLSTLO = DATNOWLO            JDLSTLO  = JDNOWLO         end ifC2       Go the the next M-th ascending node and compute the equatorC2       crossing longitude.         CALL MNODES( ORBLST , DATLST , M      , JEARTH ,      &                LTOP   , LSFLAG ,      &                DRAG   ,      &              srpflag, cr, mass,dsmadt, tsmaswitch, sigma_dsma,      &		      'TRUE', ORBNOW , DATNOW, alpha, betap )         ECL = RNG360( ORBNOW(4) - SIDANG( DATNOW , 0D0 ) )         GTLONG( NPTS ) = ECL         NREV( NPTS ) = REFIDX         do i=1,6 	   bootdata(NPTS, i) = orbnow(i)         end do         sundata(npts,1) = alpha         sundata(npts,2) = betap         if (fluxbias) then            CALL MNODES( ORBLSTHI , DATLSTHI , M      , JEARTH ,      &                LTOP   , LSFLAG ,      &                DRAG   ,      &              srpflag, cr, mass,dsmadt, tsmaswitch, sigma_dsma,      &			HI, ORBNOWHI , DATNOWHI, alpha, betap )            ECLHI = RNG360( ORBNOWHI(4) - SIDANG( DATNOWHI , 0D0 ) )            CALL MNODES( ORBLSTLO , DATLSTLO , M      , JEARTH ,      &                LTOP   , LSFLAG ,      &                DRAG   ,      &              srpflag, cr, mass,dsmadt, tsmaswitch, sigma_dsma,     &			LO, ORBNOWLO , DATNOWLO, alpha, betap )            ECLLO = RNG360( ORBNOWLO(4) - SIDANG( DATNOWLO , 0D0 ) )         end ifC      if ( trace ) thenC         write (50,*) 'COMPGT *** True:', orbin, datin, orbnow, datnowC         write (50,*) 'COMPGT *** Hi  :', orbinhi, datin, orbnowhi, C     *	    datnowhiC         write (50,*) 'COMPGT *** Lo  :', orbinlo, datin, orbnowlo, C     *	    datnowloC      end ifC2       Compute the difference between the actual and reference equatorial C2       crossing longitude and then update the reference index.         DIFF    = ECL  - XINGS( REFIDX )          IF      ( DIFF .GT. 180D0 ) THEN            DIFF = DIFF - 360D0         ELSE IF ( DIFF .LT.-180D0 ) THEN            DIFF = DIFF + 360D0         END IFC2       Compute the time in days between nodes and update total days.         JDNOW = CH2JD( DATNOW , .TRUE. , ERROR )         TDAYS = TDAYS+ ( JDNOW - JDLST )CC	Examine the ground track offset at the pseudo-site locationC	THis is the equivalent site location corresponding to theC	current node crossingC         sini = sin(orbnow(3)*pi/180.0d0)C	 IF ( trace_overflights .and. C     &     firsttime.and.(NSITES .GT. 0 ) ) THENC	   firsttime = .false.C	   CALL NEWPAGE(IPAGE, 2)C	   WRITE(8, 1200) SITE_STRATC1200       FORMAT (31x, 'Site Overflights'/C     &             31x, '----------------'/C     &             31x, 'Method = ', A6,/)CC           write(8,1202) (SITE_NAME(i),C     &         site_loc(2,i),site_gclat(i),C     &         site_loc(1,i),site_node(i),i=1,nsites)C1202       format (T16,'Site',9x,'GD Lat',9x, 'GC Lat', 6x,C     &         'Longitude',1x,'Node',C     &         /,T10,10('-'),3(1x,14('-')),1x,4('-') ,C     &         <nsites>(/,T10, A10,3F15.7,I5) )C           write(8,1204)C1204       format(//C     &         1x, 7x,'Overflight',13x,'Rev #',24x,'Longitudinal',/C     &         1x, 4x,'UTC Date/Time Site Name    Used    Latitude',C     &                '  Longitude   Offset, Km',/C     &         1x,    '----------------- ---------- ------- ----------',C     &                ' ---------- ------------')C	 END IF         do i=1,NSITESCC		warning:C		!!!!!!!C		in the next if, a site might be missed if the siteC		node # is within M/2 of ORBITS or smaller than M/2C		or the same is true of REFIDX.  Since the NOMINAL C		T/P sites are always at least 5 from the endsC		(22 & 111) this will never be a problem!!!!C            ODD = (2*(M/2).ne.M)            OneOK = ((M.EQ.1).and.(REFIDX.EQ.SITE_NODE(I)))            CLOSE = ((M.NE.1).and.     &		     (iabs(refidx-site_node(i)).le.(M+1)/2))            NEW = ( REFIDX - (M+1)/2 .NE. SITE_NODE(I) )C	    if ( iabs(REFIDX - SITE_NODE(I) ) .LE. (M+1)/2 ) then	    if ( OneOk .OR.     &		 ( CLOSE .and. ODD ) .or.     &		 ( CLOSE .and. NEW ) ) thenC	    if (trace_site) write(8,*) '**********'            SITELAT = SITE_GCLAT(i)	    if (SITE_STRAT.EQ.'KEPLER') SATGDLAT = SITELAT	    SITELONG = XINGS(REFIDX)-XINGS(SITE_NODE(i))      &		+ SITE_LOC(1,i)	    SITELONG = DMOD ( SITELONG + 360.0D0, 360.0D0)	    GTES_A = DMOD(SITELONG - XINGS(REFIDX)+360.0d0,360.0d0)	    sinl = sin (sitelat * PI/180.0d0)            cosl = cos (sitelat * PI/180.0d0)            SINDTHETA = sinl/sini	    dtheta = asin(sindtheta)	    if (GTES_A .GT. 90.0D0) dtheta=pi-dtheta            cosdtheta = cos(dtheta)            cosB = cosdtheta/cosl            GTES_B = acos(cosB) * 180.0/PI            GTES_D = GTES_B + DIFF - GTES_A	    call orb2u(orbnow,NuNode)            NuNode=dmod(NuNode - orbnow(5)+360.0d0, 360.0d0)            NuSite=dmod( NuNode + dtheta*180.0d0/PI      &             + 360.0d0, 360.0d0 )            cosNuSite = cos(NuSite*Pi/180.0d0)            SinNuSite = sin(NuSite*Pi/180.0d0)            cosEASite = (orbnow(2)+cosNuSite)/     &			(1+orbnow(2)*cosNuSite)            sinEASite = sqrt(1-orbnow(2)**2)*sinNuSite/     &			(1+orbnow(2)*cosNuSite)            EASite = Atan2 ( SinEASite, CosEASite)	    EASITE = DMOD(EASITE+TWOPI, TWOPI)            MASIte = EASite - orbnow(2) * sinEASITE	    MASITE = DMOD(MASITE+TWOPI, TWOPI)CC	    anomalistic mean motionC	    call lsrgpb ('GET', 'LSRGP_N',MeanMotion )	    TOF = DMOD( MASITE-orbnow(6)*PI/180.0d0 +TWOPI,     &			TWOPI ) / MeanMotion            EarthShift = Earth_freq*(180.0/PI)*TOF            NODESHIFT =  ( ( BOOTDATA(NPTS,4)-BOOTDATA(NPTS-1,4) )     &		            / (JDNOW-JDLST) ) * TOF/86400.0d0            GTES_DD = GTES_D+(NODESHIFT-EARTHSHIFT)            GTES = GTES_DD * cosl * DEG2KMC	    if (trace_site) thenC	       write(8,*) 'Time of Flight=',TOFC	    end ifCC	determine time of site overflight for printoutC            secnow = CH2sec( DATNOW , .TRUE. , ERROR )            xtsite = secnow + tof +     &                  (SITE_NODE(I)-REFIDX)*twopi/meanmotion             tsite = sec2ch (xtsite)            if (site_strat .eq. 'PROP') thenCC		repeat calculation using propC  	      TOF1 = 0.95 * TOF              TOF2 = 1.05 * TOF              xtsite1 = secnow + tof1              xtsite2 = secnow + tof2              tsite1 = sec2ch(xtsite1)              tsite2 = sec2ch(xtsite2)CC		prop 5% before the siteC              CALL PROP( ORBNOW , DATNOW , TOF1 , JEARTH, LTOP ,     &           LSFLAG , DRAG ,           &              srpflag, cr, mass, dsmadt, tsmaswitch,     &           sigma_dsma, 'TRUE', ORBSITE, alpha, BETAP )C              call kep2car ( ORBSITE, CARSITE, MU_EARTH )C              satGCLat1 = atan2 ( carsite(3), C     &	  	sqrt(carsite(1)**2 + carsite(2)**2) )C              satGDLat1 = atan (tan(satGCLat1)/ (1-flat)**2)*180.0d0/pi              call ORB2LatLong (ORBSITE, TSITE1, MU_EARTH, FLAT, re,     *          1.0d-5, satGDLAT1, satGCLAT1, satLONGITUDE1)CC		prop to 5% beyond the siteC              CALL PROP( ORBNOW , DATNOW , TOF2 , JEARTH, LTOP ,     &           LSFLAG , DRAG ,      &              srpflag, cr, mass, dsmadt, tsmaswitch,     &           sigma_dsma, 'TRUE', ORBSITE, alpha, BETAP )C              call kep2car ( ORBSITE, CARSITE, MU_EARTH )C              satGCLat2 = atan2 ( carsite(3), C     &		 sqrt(carsite(1)**2 + carsite(2)**2) )C              satGDLat2 = atan (tan(satGCLat2)/ (1-flat)**2)*180.0d0/pi              call ORB2LatLong (ORBSITE, TSITE2, MU_EARTH, FLAT, re,     *          1.0d-5, satGDLAT2, satGCLAT2, satLONGITUDE2)			      ErrLimit = 1.0D-5	      ErrGDLat = 1.0	      Iterations = 0	      DO While ( (Dabs(ErrGDLat) .GT. ErrLimit) .and.     &				(Iterations .LT. 10 ) )	          iterations = iterations + 1CC		  interpolate to find siteC	          TOF = TOF1 + ( (TOF2-TOF1)/(satGDLAT2-satGDLat1)) *     &		    (site_loc(2,i)-satGDLat1)                  xtsite1 = secnow + tof                   tsite1 = sec2ch(xtsite1)CC	  	  prop to interpolated locationC                  CALL PROP( ORBNOW , DATNOW , TOF , JEARTH, LTOP ,     &               LSFLAG , DRAG ,      &              srpflag, cr, mass, dsmadt, tsmaswitch,     &               sigma_dsma, 'TRUE', ORBSITE, alpha, BETAP )C                  call kep2car ( ORBSITE, CARSITE, MU_EARTH )C                  satGCLat = atan2 ( carsite(3), C     &	        	sqrt(carsite(1)**2 + carsite(2)**2) )C                  satGDLat = atan ( tan(satGCLat)/ (1-flat)**2)*180/pi                   call ORB2LatLong (ORBSITE, TSITE1, MU_EARTH, FLAT,      *                re, 1.0d-5, satGDLAT, satGCLAT, satLONGITUDE)	          ErrGDLat = SatGDLat - Site_loc(2,i)C	          if (trace_site) thenC	            write(8,*) 'Iteration ',IterationsC		    write(8,*) 'Error      = ', ErrGDLatC		    write(8,*) 'GD Lat 1   = ', satGDLat1, TOF1C		    write(8,*) 'GD Lat 2   = ', SatGDLat2, TOF2C		    write(8,*) 'Sat GD Lat = ', SatGDLat, TOFC		    write(8,*) '***'C		  end if		  if (Dabs(ErrGDLAT) .GT. ErrLimit) then	              if (SatGDLat2 .LT. SatGdLat1) then CC		      descending passC	              if (SatGDLat .LT. Site_Loc(2,i)) then		          TOF2 = TOF		          SATGDLAT2 = SATGDLAT	                else	                  TOF1 = TOF		          SATGDLAT1 = SATGDLAT	                end if	              elseCC		      ascending passC		        if (SatGDLAT .LT. Site_Loc(2,i)) then		           TOF1 = TOF		           SATGDLAT1 = SATGDLAT	                else 		           TOF2 = TOF  	 	           SATGDLAT2 = SATGDLAT	                end if	              end if	          end if	      End doCC              SatLongitude = (180.0/PI) * C     &		      atan2 ( CARSITE(2), CARSITE(1) )C     &               - sidang ( sec2ch(secnow+tof), 0.0d0 )               SatLongitude = dmod ( SatLongitude + 720.0d0, 360.0d0)	      GTES = ( SatLongitude - SiteLong ) * cosl * DEG2KM            end ifC	    if (trace_site) thenC	        write(8,*) 'Sat GC Latitude = ', satGCLatC	        write(8,*) 'Sat GD Latitude = ', satGDLatC		write(8,*) 'Site GD Latitude = ', site_loc(2,i)C	        write(8,*) 'Error in Latitude = ',ErrGDLatC                write(8,*) 'Sat Longitude = ',SatLongitudeC	        write(8,*) 'Sat Pseudo Longitude = ', SatLongitudeC     &			-(  XINGS(REFIDX)-XINGS(SITE_NODE(i)))C                write(8,*) 'SiteLong = ',SiteLongC	        write(8,*) 'Offset by Prop = ', GTES, ' km.'C	    end ifC            if (trace_overflights) then C               write(8,1234) tsite(1:17), site_name(i), REFIDX, C     &		   REFIDX.EQ.SITE_NODE(I), satGDLat,C     &		   DMOD( satLongitude+360.0D0-C     &		      (XINGS(REFIDX)-XINGS(SITE_NODE(i))), 360.0d0), C     &			gtesC 1234          format(1x, A17,1x, A10,I5,1x,L1,F12.5,F11.5,F13.5)C	    end if	    NOVERFLIGHTS(I) = NOVERFLIGHTS(I)+1            overflights(I,NOVERFLIGHTS(I),1) = xtsite            overflights(I,NOVERFLIGHTS(I),2) = GTES            overflights(I,NOVERFLIGHTS(I),3) = satGDLAT            overflights(I,NOVERFLIGHTS(I),4) =      &		 DMOD( satLongitude+360.0D0-     &                (XINGS(REFIDX)-XINGS(SITE_NODE(i))), 360.0d0)            overflights(I,NOVERFLIGHTS(I),5) = dble(real(REFIDX))                  end if	 end do	                                               REFIDX = REFIDX + M         IF ( REFIDX .GT. ORBITS ) REFIDX = REFIDX - ORBITS         if (fluxbias ) then            DIFFHI    = ECLHI  - XINGS( REFIDXHI )             DIFFLO    = ECLLO  - XINGS( REFIDXLO )             IF      ( DIFFHI .GT. 180D0 ) THEN               DIFFHI = DIFFHI - 360D0            ELSE IF ( DIFFHI .LT.-180D0 ) THEN               DIFFHI = DIFFHI + 360D0            END IF            IF      ( DIFFLO .GT. 180D0 ) THEN               DIFFLO = DIFFLO - 360D0            ELSE IF ( DIFFLO .LT.-180D0 ) THEN              DIFFLO = DIFFLO + 360D0            END IF            REFIDXHI = REFIDXHI + M            IF ( REFIDXHI .GT. ORBITS ) REFIDXHI = REFIDXHI - ORBITS            REFIDXLO = REFIDXLO + M            IF ( REFIDXLO .GT. ORBITS ) REFIDXLO = REFIDXLO - ORBITS         end ifC         if (trace) thenC            write (50,*) 'COMPGT ECL,HI,LO',ECL,ECLHI,ECLLOC            write (50,*) 'COMPGT IDX,HI,LO',REFIDX,REFIDXHI,REFIDXLOC            write (50,*) 'COMPGT DIF,HI,LO',DIFF,DIFFHI,DIFFLOC         end ifC2       Convert the difference to kilometers.         DGT    = DIFF * DEG2KM          if (fluxbias) then            dgthi_last = dgthi            dgtlo_last = dgtlo            DGTHI  = DIFFHI * DEG2KM            DGTLO  = DIFFLO * DEG2KM         end ifC         if (trace) thenC            write(50,*) 'COMPGT DGT,HI,LO:',DGT,DGTHI,DGTLOC         end if         if (fluxbias) then            JDNOWHI = CH2JD( DATNOWHI , .TRUE. , ERROR )            JDNOWLO = CH2JD( DATNOWLO , .TRUE. , ERROR )            TDAYSHI_LAST = TDAYSHI            TDAYSLO_LAST = TDAYSLO            TDAYSHI = TDAYSHI + JDNOWHI - JDLSTHI            TDAYSLO = TDAYSLO + JDNOWLO - JDLSTLOCC	    if necessary, save a new point to flux/gt bias fileC            itdays = int(tdays)            if ( itdays .gt. itdayslast) then		call interp_line ( dble(itdays), tdayshi_last, tdayshi,     &		     dgthi_last, dgthi, dgthi_used )		call interp_line ( dble(itdays), tdayslo_last, tdayslo,     &		     dgtlo_last, dgtlo, dgtlo_used )		if (itdays.gt.0)      &             drag_bias(itdays) = max ( abs(dgthi_used)-dgt,     &				         abs(dgtlo_used)-dgt )		itdayslast = itdays            end if         end ifC2       Store offset and time in data arrays.         TIMVEC( NPTS ) = TDAYS         DGTVEC( NPTS ) = DGT         GTE_DV = 0.001 * SF_DVOD * partial_dGTdV * DV_ERROR * TDAYS         GTE_OD = 0.001 * SF_DVOD * partial_dGTda * DA_OD * TDAYS         IF (anomalous_force .and. GTE_BOOST_ARRAY) THENCC		INSERT CODE HERE TO OBTAIN DA_BOOST FROM THE APPROPRIATEC		DATA ARRAY, DSMADT_SIGMAS(I)CC		DA_BOOST = DATA FROM ARRAY * PERIOD * M / 86400.0CC		NEED ALSO TO INCORPORATE SCALE FACTOR INTO EQUATIONS            IF ( DSMADT_EPOCH .EQ. ' ') then              IDATE = finddate ( DATNOW, .FALSE., DSMADT_dates,      &	   	   XDSMADT_DATES, nDSMADT_DATA )              IF (IDATE .LT. 1 .OR. IDATE .GE. NDSMADT_DATA) THEN                 WRITE(8,*) 'Time ', datnow,' is out of range of ',     &			' Boost Sigma Array.'                 DA_BOOST = 0.0D0              ELSE                 XT1 = XDSMADT_DATES(IDATE)                 XT2 = XDSMADT_DATES(IDATE+1)                 Y1 = dsmadt_sigmas(IDATE)                 Y2 = dsmadt_sigmas(IDATE+1)                 da_boost = y1 +      &	     	   (CH2SEC(DATNOW, .TRUE., ERROR) - XT1)     &	   	   *( (y2-y1)/(XT1-XT2) )                 da_boost = da_boost * PERIOD_DAYS              END IF           ELSE   	      dsmadt_epochjd = ch2jd ( dsmadt_epoch, .true., ERROR)              IDATE = jdnow - dsmadt_epochjd              IF (IDATE .LT. 1 .OR. IDATE .GE. NDSMADT_DATA) THEN                 WRITE(8,*) 'Time ', datnow,' is out of range of ',     &			' Boost Sigma Array.'                 DA_BOOST = 0.0D0              ELSE                 da_boost = DSMADT_SIGMAS(IDATE)                 da_boost = da_boost * M * PERIOD_DAYS              END IF           END IF           GTE_BOOST_OLD = GTE_BOOST           IF (QUAD_ERR_BOOST) THEN   	      ALPHA_BOOST_OLD = ALPHA_BOOST	      GAMMA_BOOST_OLD = GAMMA_BOOST              ALPHA_BOOST = ALPHA_BOOST_OLD +      &			m * (PERIOD_DAYS**2) * (DA_BOOST**2)	      GAMMA_BOOST = 2.0*m*ALPHA_BOOST_OLD + GAMMA_BOOST_OLD     &		+ MMPRIME  * (PERIOD_DAYS**2) * (DA_BOOST**2)	      BETA_BOOST = BETA_STAR * (DA_BOOST**2)              GTE_BOOST = SQRT( GTE_BOOST_OLD**2      &		+ ( PARTIAL_DGTDA**2 )      &		   * ( MPRIME * ALPHA_BOOST_OLD +      &		       M * GAMMA_BOOST_OLD + BETA_BOOST ) )C              write(8,*) DATNOW,' TDAYS=', TDAYS,C     &		' I=',IDATE,' DA_BOOST=',DA_BOOST,' M=',M,C     &		' M''=',MPRIME,' MM''=',MMPRIME, C     &		' AL=',ALPHA_BOOST_OLD, ' GAM=',GAMMA_BOOST_OLD,C     &		' BETA*=',BETA_STAR, C     &		' BETA=',BETA_BOOST, ' GT=',GTE_BOOST           ELSE              DELTA_BOOST_OLD = DELTA_BOOST	      DELTA_BOOST = DELTA_BOOST_OLD +      &			M * M * PERIOD_DAYS *      &			PARTIAL_DGTDA * DA_BOOST	      GTE_BOOST = GTE_BOOST_OLD + DELTA_BOOST_OLD +     &			PARTIAL_DGTDA * PERIOD_DAYS * DA_BOOST *     &			0.5 * mmprime           END IF	 ELSE if (anomalous_force) then            if (quad_err_boost) then               GTE_BOOST = partial_dgtda_boost *      &		da_boost *      &		sqrt (2.0d0/3.0d0) *     &		sqrt (  ( tdays * 86400.0 / period) *     &			( tdays - PERIOD/86400.0) *      &	                ( 2*tdays - PERIOD/86400.0)   )C	        write(8,*) tdays,' ',GTE_BOOST            else            GTE_BOOST = partial_dgtda_boost *      &		da_boost *     &		tdays * (1 + tdays * 86400.0 / PERIOD )            end if	 else	    gte_boost =0.0d0	 END IF                GTE_BOOST_ENV = 0.001 * SF_BOOST * GTE_BOOST         GTE_DVOD = sqrt ( GTE_DV**2 + GTE_OD**2 )         if (fluxbias) then            call interp_line ( tdays, tdayshi_last, tdayshi,     &		dgthi_last, dgthi, dgthi_used )            call interp_line ( tdays, tdayslo_last, tdayslo,     &          dgtlo_last, dgtlo, dgtlo_used )            gte_drag = max (abs (dgthi_used - dgt),     &			    abs (dgtlo_used - dgt)  )	    old_gte_drag_hi = gte_drag_hi	    old_gte_drag_lo = gte_drag_lo            GTE_DRAG_HI = abs (dgthi_used - dgt)            GTE_DRAG_LO = abs (dgtlo_used - dgt)         else            call interp_drag_bias (tdays, drag_bias, ndrag_bias,      &			gte_drag )	    old_gte_drag_hi = gte_drag_hi	    old_gte_drag_lo = gte_drag_lo            gte_drag_hi = gte_drag            gte_drag_lo = gte_drag         end if         delta_gte_drag_hi = gte_drag_hi - old_gte_drag_hi         delta_gte_drag_lo = gte_drag_lo - old_gte_drag_lo         optimistic_gte_drag_hi = sqrt (      &       optimistic_gte_drag_hi**2 + delta_gte_drag_hi**2 )         optimistic_gte_drag_lo = sqrt (      &       optimistic_gte_drag_lo**2 + delta_gte_drag_lo**2 )         if ( quad_err_drag) then	    GTE_DRAG_EAST = sf_drag * OPTIMISTIC_GTE_DRAG_HI            GTE_DRAG_WEST = sf_drag * OPTIMISTIC_GTE_DRAG_LO         else	    GTE_DRAG_EAST = sf_drag * GTE_DRAG_HI	    GTE_DRAG_WEST = sf_drag * GTE_DRAG_LO         end if         GT_ERROR_EAST = sqrt ( GTE_DVOD**2 +      &		GTE_DRAG_EAST**2 + GTE_BOOST_ENV**2 )         GT_ERROR_WEST = sqrt ( GTE_DVOD**2 +      &		GTE_DRAG_WEST**2 + GTE_BOOST_ENV**2 )         DGTWest = DGT - GT_ERROR_WEST         DGTEast = DGT + GT_ERROR_EAST         EASTVEC( NPTS )    = DGTEast         WESTVEC( NPTS )    = DGTWest         BIAS_ODE( NPTS )   = SNGL ( DGT+abs(GTE_OD) )         BIAS_DVE( NPTS )   = SNGL ( DGT+abs(GTE_DV) )         BIAS_DRAGE( NPTS ) = SNGL ( DGT+abs(GTE_DRAG_EAST) )         BIAS_boostE( NPTS ) = SNGL ( DGT+abs(GTE_boost_ENV) )         BIAS_ODW( NPTS )   = SNGL ( DGT-abs(GTe_OD) )         BIAS_DVW( NPTS )   = SNGL ( DGT-abs(GTe_DV) )         BIAS_DRAGW( NPTS ) = SNGL ( DGT-abs(GTe_DRAG_WEST) )         BIAS_boostw( NPTS ) = SNGL ( DGT-abs(GTE_boost_ENV) )      	 if ( watch .and. TERMINAL.eq.'VT100' ) then	     write (6,*)   goto_string (14,1), datnow             write (6,100) goto_string (14,63),tdays             write (6,100) goto_string (15,6),dgtwest             write (6,100) goto_string (16,6),dgt             write (6,100) goto_string (17,6),dgteast	     write (6,100) goto_string(15,33), orbnow (1)	     write (6,100)goto_string(16,33), orbnow (2)	     write (6,100) goto_string(17,33), orbnow (3)	     write (6,100) goto_string(15,63), orbnow (4)	     write (6,100) goto_string(16,63), orbnow (5)  	     write (6,100) goto_string(17,63), orbnow (6)  100        format(' ',A8,f15.10)		 end ifC2       Is ground track within the valid band?CC	This test will only pass if on the previous iteration, theC		ground track was OUT of the valid band. Thus if weC		have JUST ENTERED the valid band, then set theC		appropriate flag to say "KEEP GOING"C         IF ( .NOT. WASIN ) THEN            if ( target_strat .eq. 'UNBIASED' ) then               IF ( BOUNDS(1) .LT. DGT .AND. DGT .LT. BOUNDS(2) )      &            WASIN = .TRUE.             else if ( target_strat .eq. 'WESTGT' ) then               IF ( BOUNDS(1) .LT. DGTwest .AND.      &              DGTwest .LT. BOUNDS(2) )      &            WASIN = .TRUE.             else if ( target_strat .eq. 'EASTGT' ) then               IF ( BOUNDS(1) .LT. DGTeast .AND.      &            DGTeast .LT. BOUNDS(2) )      &            WASIN = .TRUE.             endif         END IFCC	has the unbiased of the 3 ground tracks returned? if so, saveC		the time for the reportC         IF ( .NOT. WASIN_UNBIASED ) THEN            if ( BOUNDS(1) .LT. DGT .AND. DGT .LT. BOUNDS(2) )      &            WASIN_UNBIASED = .TRUE.          else if ( ( tmaneuver(2) .le. 0 ) .and.     &             ( dgt .lt. bounds(1) .or.     &               dgt .gt. bounds(2) ) ) then                 tmaneuver(2) = tdays		 norbits(2) = npts*M	         ncycs =  norbits(2) / orbits 		 tmaneuverc(2) = ncycs*cycle_length		 norbitsc(2) = ncycs*orbits         end ifCC	has the eastermost of the 3 ground tracks returned? if so, saveC		the time for the reportC         IF ( .NOT. WASIN_EAST ) THEN            if ( BOUNDS(1) .LT. DGTeast .AND.      &             DGTeast .LT. BOUNDS(2) )      &             WASIN_EAST = .TRUE.          else if ( ( tmaneuver(3) .le. 0 ) .AND.     &           ( dgteast .lt. bounds(1) .or.     &             dgteast .gt. bounds(2) ) ) then              tmaneuver(3) = tdays              norbits(3) = npts*M	      ncycs = norbits(3) / orbits 	      tmaneuverc(3) = ncycs*cycle_length              norbitsc(3) = ncycs*orbits         end ifCC	has the westermost of the 3 ground tracks returned? if so, saveC		the time for the reportC         IF ( .NOT. WASIN_WEST )  THEN            IF ( BOUNDS(1) .LT. DGTwest .AND.      &           DGTwest .LT. BOUNDS(2) )      &           WASIN_weST = .TRUE.          else if ( ( tmaneuver(1) .le. 0 ) .and.     &           ( DGTwest .lt. bounds(1) .or.     &             dgtwest .gt. bounds(2) ) )then      		tmaneuver(1) = tdays	        norbits(1) = npts*M	        ncycs = norbits(1) / orbits 		tmaneuverc(1) = ncycs*cycle_length		norbitsc(1) = ncycs*orbits         end ifC2       Is ground track any further west?         IF ( DGT .LT. LIMITS(2,2) ) THEN            LIMITS(2,1) = TDAYS            LIMITS(2,2) = DGT         END IF         if ( dgtwest .lt. limits_west(2,2)) then            limits_west(2,1) = tdays	    limits_west(2,2) = dgtwest         end if         if ( dgteast .lt. limits_east(2,2)) then            limits_east(2,1) = tdays	    limits_east(2,2) = dgteast         end ifC2       Is ground track any further east?         IF ( DGT .GT. LIMITS(3,2) ) THEN            LIMITS(3,1) = TDAYS            LIMITS(3,2) = DGT         END IF         IF ( DGTwest .GT. LIMITS_west(3,2) ) THEN            LIMITS_west(3,1) = TDAYS            LIMITS_west(3,2) = DGTwest         END IF         IF ( DGTeast .GT. LIMITS_east(3,2) ) THEN            LIMITS_east(3,1) = TDAYS            LIMITS_east(3,2) = DGTeast         END IFC2       Check to see if stopping criteria was met. If COMPGT is simplyC2       running out a ground track, then continue for specified numberC2       of days. Otherwise, go until ground track leaves valid band.C2       However, if the track was never in the band, terminate afterC2       TOLONG days.CC	 first test : for a RUNOUTC         IF ( DAYS .GT. 0 ) THEN            IF ( TDAYS .GT. TSTOP ) GO TO 902CC	 second test: never made it into the valid band, try againC	 with a bettern delta vC         ELSE IF ( .NOT. WASIN ) THEN            IF ( TDAYS .GT. TSTOP ) GO TO 902CC	 otherwise, see if the ground track just crossed out of theC	 valid band; stop if all doneC         ELSE IF ( WASIN ) THEN            if ( target_strat .eq. 'UNBIASED' ) then               IF ( DGT .LT. BOUNDS(1) .OR.      &		    BOUNDS(2) .LT. DGT ) GO TO 902            else if ( target_strat .eq. 'WESTGT' ) then               IF ( DGTwest .LT. BOUNDS(1) .OR.      &		    BOUNDS(2) .LT. DGTwest ) GO TO 902            else if ( target_strat .eq. 'EASTGT' ) then               IF ( DGTeast .LT. BOUNDS(1) .OR.      &		    BOUNDS(2) .LT. DGTeast ) GO TO 902            endif         END IFC2       If no stopping criteria was met, then take another step.         GO TO 901C1    End of Do Loop.902   CONTINUEC1    Save the last node and orbit.      CALL DVMOVE( 6 , ORBNOW , ORBOUT )      DATOUT      = DATNOW      LIMITS(4,1) = TDAYS      LIMITS(4,2) = DGT      LIMITS_WEST(4,1) = TDAYS      LIMITS_WEST(4,2) = DGTwest      LIMITS_EAST(4,1) = TDAYS      LIMITS_EAST(4,2) = DGTeastCC     if flux biasing mode, save the gt bias component due to fluxC      if (fluxbias) ndrag_bias = int(tdays)C1    End of COMPGT.      RETURN      END