C$Procedure                        DOMNVRC      SUBROUTINE DOMNVR ( OPRE , DV , PITCH , YAW , OPOST , DVVEC,     *			  DVLCR )CC*******************************************************************************CC       Copyright (C) 1993, California Institute of Technology.  U.S.C       Government Sponsorhip under NASA Contract NAS7-918 isC       acknowledged.CC*******************************************************************************CCC$ LogCC  19-Oct-1989 - Eric Cannell     - creation of DVDORB ProgramC   1-MAR-1990 - Eric Cannell     - hacked DVDORB to get this routineC  12-MAR-1990 - Eric Cannell     - changed algorithm to add dV to CartesianC                                   stateC   9-APR-1992 - Bruce Shapiro    - include DVLCR as return parameterCC$ PurposeCC  DOMNVR determines the change in the classical orbital elements dueC  to a maneuver defined by a magnitude, pitch, and yaw.CC$ Input_ArgumentsCC  Name    Type   Dim        Units   DescriptionC  -----------------------------------------------------------------------------C  OPRE      DP     6       km,deg   pre-maneuver orbit (a,e,i,LAN,w,M)C  DV        DP     1        m/sec   maneuver magnitudeC  PITCH     DP     1          deg   maneuver pitch angleC  YAW       DP     1          deg   maneuver yaw angleCC$ Output_ArgumentsCC  Name    Type   Dim        Units   DescriptionC  -----------------------------------------------------------------------------C  OPOST     DP     6       km,deg   post-maneuver orbit (a,e,i,LAN,w,M)C  DVVEC     DP     3        m/sec   inertial dV applied (dvx,dvy,dvz)C  DVLCR     DP     3        m/sec   dv in long track,cross track, radialC               C$ ParametersC      DOUBLE PRECISION     PI      PARAMETER          ( PI     = 3. 14159 26535 89793 23846 D0 )      DOUBLE PRECISION     D2R      PARAMETER          ( D2R    = PI / 180.0D0 )CC$ Declarations_of_Input_and_Output_ArgumentsC      DOUBLE PRECISION     DV      DOUBLE PRECISION     DVVEC  ( 3 )      double precision     dvlcr  ( 3 )      INTEGER              I      DOUBLE PRECISION     OPRE   ( 6 )      DOUBLE PRECISION     OPOST  ( 6 )      DOUBLE PRECISION     PITCH      DOUBLE PRECISION     YAWCC$ Declarations_of_Local_Variables                              C      DOUBLE PRECISION     DVC      DOUBLE PRECISION     DVL      DOUBLE PRECISION     DVR      DOUBLE PRECISION     GM      DOUBLE PRECISION     J2      DOUBLE PRECISION     P      ( 3 )      DOUBLE PRECISION     R      ( 3 )      DOUBLE PRECISION     RP      DOUBLE PRECISION     RR      DOUBLE PRECISION     STATE  ( 6 )      DOUBLE PRECISION     Y      ( 3 )CC$ External_StatementsC      DOUBLE PRECISION     RNG360      EXTERNAL             RNG360C       - via namelist $constants, in block physical_constantsC      double precision earth_rad                ! in kilomters      double precision mu_earth                 ! km**3/sec      double precision mu_moon                  ! km**3/sec      double precision mu_sun                   ! km**3/sec      double precision sid_day                  ! secondsCC       - derived constants, in block physical_constantsC      double precision earth_freq               ! radians / second      double precision earth_rate               ! meters / day      double precision deg_to_km                ! kilometers/deg      common / physical_constants /     &    earth_rad,  earth_freq,  earth_rate,    mu_earth,     &    mu_moon,    mu_sun,         sid_day,    deg_to_kmCC$ Method                    C-&C1    Set up MASL*VECTOR for Earth as central body.C      CALL MVINFO( 'EARTH' , ' ' , GM , J2 , RP , RR )C1    Convert classical elements (a,e,i,LAN,w,M) to Cartesian state C1    (x,y,z,vx,vy,vz).C      CALL ORBIN ( OPRE  ,  11 )C      CALL ORBOUT( STATE , 112 )       GM = MU_EARTH       CALL KEP2CAR ( OPRE, STATE, GM )C1    Compute the yaw axis.C      CALL VUNIT( Y , STATE , 3 )C      CALL VNEG ( Y , Y     , 3 )      DO I=1,3        Y(I) = -STATE(I)      END DO      CALL UNIT (Y, Y)C1    Compute the pitch axis.C      CALL UCROSS( P , Y , STATE(4) )      CALL CROSS (Y, STATE(4), P)      CALL UNIT (P, P)C1    Compute the roll axis.C      CALL UCROSS( R , P , Y )      CALL CROSS ( P, Y, R)      CALL UNIT( R, R)C1    Compute delta-V in L-C-R.      DVL = DV * DCOS( D2R * PITCH ) * DCOS( D2R * YAW ) / 1.0D3      DVC = DV * DCOS( D2R * PITCH ) * DSIN( D2R * YAW ) / 1.0D3      DVR = DV * DSIN( D2R * PITCH )                     / 1.0D3      dvlcr(1) = dvl      dvlcr(2) = dvc      dvlcr(3) = dvrC1    Scale the yaw, pitch, and roll axes with dV.C      CALL VSCALE( Y , Y , DVR , 3 )C      CALL VSCALE( P , P , DVC , 3 )C      CALL VSCALE( R , R , DVL , 3 )      DO I=1,3	 Y(I) = Y(I) * DVR	 P(I) = P(I) * DVC         R(I) = R(I) * DVL      END DOC1    Add the dV to the state velocity.       DO 101 I = 1 , 3         DVVEC(I  ) = Y(I) + P(I) + R(I)         STATE(I+3) = STATE(I+3) + DVVEC(I)101   CONTINUEC1    Convert the new state to classical elements.C      CALL ORBIN ( STATE , 112 )C      CALL ORBOUT( OPOST ,  11 )      CALL CAR2KEP ( STATE, OPOST, GM )C1    Make sure that LAN, w, and M are in range of 0..360.      OPOST(4) = RNG360( OPOST(4) )      OPOST(5) = RNG360( OPOST(5) )      OPOST(6) = RNG360( OPOST(6) )C1    Convert dV vector to meter/sec.C      CALL VSCALE( DVVEC , DVVEC , 1D3 , 3 )      DO I=1,3	 DVVEC(I) = 1000.0D0 * DVVEC(I)      END DO      RETURN      END